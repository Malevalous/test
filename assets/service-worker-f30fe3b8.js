import { M as b } from "./constants-c64b297c.js";
globalThis.jotaiAtomCache = globalThis.jotaiAtomCache || { cache: new Map, get(e, t) { return this.cache.has(e) ? this.cache.get(e) : (this.cache.set(e, t), t) } };
const d = { posts: "GroupsCometMembersPageNewForumMembersSectionRefetchQuery", reels: "GroupsCometMembersPageNewMembersSectionRefetchQuery", tagged: "CometProfilePlusNonRegularVideosRootQuery" };
const _ = (e, t) => { const r = {}; return e && t.forEach(a => { const o = e[a]; r[a] = Array.isArray(o) && o.length > 0 && typeof o[0] == "string" ? o[0] : "" }), r };
const T = e => { var c, s; if (e.method !== "POST" || !e.url.includes("api/graphql")) return; const t = (c = e.requestBody) == null ? void 0 : c.formData, a = _(t, ["fb_api_req_friendly_name", "av", "fb_dtsg", "doc_id", "variables"]); if (!Object.values(d).includes(a.fb_api_req_friendly_name)) return; const o = (s = Object.entries(d).find(([, i]) => i === a.fb_api_req_friendly_name)) == null ? void 0 : s[0]; o && chrome.storage.local.get(["requests"], ({ requests: i = [] }) => { Array.isArray(i) || (i = []); const n = e.tabId; let l = !1; const h = i.map(u => u.tabId === n ? (l = !0, { ...u, [o]: a }) : u); l || (h.push({ tabId: n, [o]: a }), h.length > 100 && h.splice(0, h.length - 100)), chrome.storage.local.set({ requests: h }) }) };
const k = e => { /\/api\/v1\/feed\/(saved\/posts|collection)\//i.test(e.url) && chrome.storage.local.get(["headers"], t => { let r = Array.isArray(t.headers) ? t.headers : []; const a = e.tabId; let o = !1; for (const c of r) if (c.tabId === a) { c.url = e.url, c.headers = e.requestHeaders, o = !0; break } o || (r.push({ tabId: a, url: e.url, headers: e.requestHeaders }), r.length > 256 && (r = r.slice(-256))), chrome.storage.local.set({ headers: r }) }) };
const A = e => new URL(e).pathname.split("/").pop() || "download";
function p(e, t) { const { url: r, folder: a, type: o, fileName: c } = e; if (!r) return t({ ok: !1, error: "No URL provided" }), !0; let s = c || A(r); return !s.includes(".jpg") && !s.includes(".mp4") && !s.includes(".gif") && (s += o === "video" ? ".mp4" : o === "gif" ? ".gif" : ".jpg"), a && (s = `${a}/${s}`), chrome.downloads.download({ url: r, filename: s, saveAs: !1, conflictAction: "uniquify" }, i => { if (chrome.runtime.lastError) { const n = chrome.runtime.lastError; console.error("Download failed:", n.message), t({ ok: !1, error: n.message }) } else t({ ok: !0, downloadId: i }) }), !0 }
const f = async (e, t, r) => { if (r.status === "complete") { if (!r.url) return; } };
const g = async () => (await chrome.tabs.query({ active: !0, currentWindow: !0 }))[0];
function w(e, t) { return (e.tab ? Promise.resolve(e.tab) : g()).then(a => { const o = `${a.id}`; chrome.storage.local.get(["current_task", "last_task_time"], c => { const s = c.current_task || null, i = c.last_task_time || 0; if (Date.now() - i > 10 * b) { chrome.storage.local.set({ current_task: o, last_task_time: Date.now() }), t({ ok: !0 }); return } if (!s) { chrome.storage.local.set({ current_task: o }), t({ ok: !0 }); return } chrome.tabs.query({}, n => { n.some(h => h.id === parseInt(s)) && s !== o ? t({ ok: !1 }) : (chrome.storage.local.set({ current_task: o }), t({ ok: !0 })) }) }) }).catch(a => { console.error("Failed to start task:", a), t({ ok: !1 }) }), !0 }
function y(e, t) { const r = e.tab || g(); Promise.resolve(r).then(a => { const o = `${a.id}`; chrome.storage.local.get(["current_task"], c => { (c.current_task || null) === o ? (chrome.storage.local.set({ current_task: null }), t({ ok: !0 })) : t({ ok: !1 }) }) }).catch(a => { console.error("Failed to stop task:", a), t({ ok: !1 }) }), t({ ok: !1 }) }
function C(e, t) { const r = e.tab || g(); return Promise.resolve(r).then(() => { chrome.storage.local.get(["current_task"], () => { chrome.storage.local.set({ current_task: null, contextId: null, nextCursor: "" }, () => { t({ ok: !0 }) }) }) }).catch(a => { console.error("Failed to reset task:", a), t({ ok: !1 }) }), !0 }
const j = async () => (await chrome.tabs.query({ active: !0, currentWindow: !0 }))[0];
function E(e, t) { return e.tab ? t({ tab: e.tab }) : j().then(r => { t({ tab: r }) }).catch(r => { console.error("Failed to get tab:", r), t({ tab: null }) }), !0 }
function M(e, t) { return chrome.cookies.get({ url: "https://www.instagram.com", name: "csrftoken" }, r => { t({ csrfToken: r == null ? void 0 : r.value }) }), !0 }
function P(e, t) { const r = navigator.userAgent, a = r.includes("Chrome") ? "Chrome" : r.includes("Edg") ? "Edge" : "Firefox"; return t({ browser: a }), !0 }
function S(e, t, r) { var a; try { const o = r == null ? void 0 : r.url; if (!o) return console.error("Open and toggle message missing URL"), t({ success: !1, error: "Missing URL in request" }), !0; const c = (a = e.tab) == null ? void 0 : a.id; return c ? (chrome.tabs.onUpdated.addListener(function s(i, n) { i === c && n.status === "complete" && (chrome.tabs.onUpdated.removeListener(s), setTimeout(async () => { try { await chrome.tabs.sendMessage(c, { action: "toggle___INSTAGRAM_SAVED_POSTS_EXPORTER_PANEL__" }), t({ success: !0 }) } catch (l) { console.error("Failed to toggle panel after navigating:", l), t({ success: !1, error: String(l) }) } }, 500)) }), chrome.tabs.update(c, { url: o }).catch(s => { console.error("Error updating tab:", s), t({ success: !1, error: String(s) }) }), !0) : (console.error("No tab ID found in sender"), t({ success: !1, error: "No tab ID found" }), !0) } catch (o) { return console.error("Error processing open and toggle request:", o), t({ success: !1, error: String(o) }), !0 } }
function v(e, t) { const r = e.tab || g(); return Promise.resolve(r).then(a => { a.id && chrome.tabs.sendMessage(a.id, { action: "toggle___INSTAGRAM_SAVED_POSTS_EXPORTER_PANEL__" }), t({ ok: !0 }) }).catch(a => { console.error("Failed to toggle pannel:", a), t({ ok: !1 }) }), !0 }
chrome.action.onClicked.addListener(async e => { if (!e.url || !e.url.includes("instagram.com")) { if (e.id) { const t = e.id; chrome.tabs.onUpdated.addListener(function r(a, o) { a === t && o.status === "complete" && (chrome.tabs.onUpdated.removeListener(r), setTimeout(async () => { try { await chrome.tabs.sendMessage(t, { action: "toggle___INSTAGRAM_SAVED_POSTS_EXPORTER_PANEL__" }) } catch (c) { console.error("Failed to toggle panel after navigating to Pinterest:", c) } }, 500)) }), chrome.tabs.update(t, { url: "https://www.instagram.com" }) } return } if (e.id) try { await chrome.tabs.sendMessage(e.id, { action: "toggle___INSTAGRAM_SAVED_POSTS_EXPORTER_PANEL__" }) } catch (t) { console.info("Failed to send message to tab:", t), console.info("Reloading tab to inject content script..."), await chrome.tabs.reload(e.id), chrome.tabs.onUpdated.addListener(function r(a, o) { a === e.id && o.status === "complete" && (chrome.tabs.onUpdated.removeListener(r), setTimeout(async () => { try { await chrome.tabs.sendMessage(e.id, { action: "toggle___INSTAGRAM_SAVED_POSTS_EXPORTER_PANEL__" }) } catch (c) { console.error("Failed to send message after reload:", c) } }, 500)) }) } });
chrome.runtime.onMessage.addListener(function (e) { return !1 });
chrome.runtime.onInstalled.addListener(async () => { await chrome.storage.local.set({ request_interval: 0, current_task: null, last_task_time: 0, requests: [] }) });
chrome.runtime.onMessage.addListener((e, t, r) => { if (e.target === "background") switch (e.action) { case "get_tab": return E(t, r); case "start_task": return w(t, r); case "stop_task": return y(t, r); case "reset_task": return C(t, r); case "get_csrf_token": return M(t, r); case "get_browser": return P(t, r); case "download_item": return p(e.data, r); case "open_and_toggle": return S(t, r, e.data); case "toggle_panel": return v(t, r); default: console.warn("Unknown message action:", e.action), r(null); break } });
chrome.tabs.onRemoved.addListener(e => { chrome.storage.local.get(["current_task", "requests"], t => { let r = t.current_task || null, a = t.requests || []; r === `${e}` && (r = null, chrome.storage.local.set({ current_task: null })), Array.isArray(a) && (a = a.filter(o => o.tabId !== e), a.length > 256 && a.splice(0, a.length - 256), chrome.storage.local.set({ requests: a })) }) });
chrome.webRequest.onBeforeSendHeaders.addListener(k, { urls: ["*://*.instagram.com/*"] }, ["requestHeaders"]);
chrome.webRequest.onBeforeRequest.addListener(T, { urls: ["*://*.instagram.com/*"] }, ["extraHeaders", "requestBody"]);
